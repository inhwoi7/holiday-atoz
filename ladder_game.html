<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사다리 게임</title>
    <style id="ladder-game-style">
    body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background-color: #f4f4f4;
    }

    h1 {
        color: #333;
    }

    .controls, .inputs, #ladder-container, #game-output {
        background-color: #fff;
        padding: 20px;
        margin: 10px 0;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        width: 100%;
        max-width: 800px;
    }

    .controls label, .controls input, .controls button {
        margin-right: 10px;
    }

    .inputs {
        display: flex;
        justify-content: space-around;
        gap: 20px;
    }

    .names-input, .results-input {
        flex: 1;
    }

    .player-input-group {
        display: flex;
        margin-bottom: 5px;
    }

    .player-input-group label {
        width: 30px;
        flex-shrink: 0;
    }

    .ladder-column {
        display: inline-block;
        vertical-align: top;
        margin: 0 10px;
    }

    .ladder-line {
        width: 0; /* No background, use border */
        border-left: 2px dotted #ccc; /* Dotted gray line */
        position: relative;
    }

    .rung {
        height: 2px;
        background-color: #333;
        position: absolute;
    }

    .ladder-path {
        position: absolute;
        background-color: red;
        opacity: 0.7;
    }

    button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
    }

    button:hover {
        background-color: #0056b3;
    }

    #game-output div {
        padding: 5px;
        border-bottom: 1px solid #eee;
    }

    #game-output div:last-child {
        border-bottom: none;
    }

    .ladder-top-name, .ladder-bottom-result {
        position: absolute;
        width: 70px; /* Adjust based on column spacing */
        text-align: center;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transform: translateX(-50%); /* Center based on column line */
    }

    .ladder-top-name {
        top: -30px; /* Position above the ladder */
        left: 50%;
    }

    .ladder-bottom-result {
        bottom: -30px; /* Position below the ladder */
        left: 50%;
        transition: color 0.3s ease-in-out;
    }

    .blink-winner {
        animation: blink 1s step-end infinite;
    }

    @keyframes blink {
        0% { opacity: 1; color: inherit; } /* Start visible, default color */
        25% { opacity: 0.5; color: gold; } /* Flash gold and semi-transparent */
        50% { opacity: 1; color: red; }    /* Visible, flash red */
        75% { opacity: 0.5; color: gold; } /* Flash gold and semi-transparent */
        100% { opacity: 1; color: inherit; } /* End visible, back to default color */
    }

</style>
</head>
<body>
    <h1>사다리 게임</h1>

    <div class="controls">
        <label for="num-players">참가자 수 (2-10명):</label>
        <input type="number" id="num-players" value="5" min="2" max="10">
        <button id="generate-inputs">입력창 생성</button>
    </div>

    <div class="inputs">
        <div class="names-input">
            <h2>참가자 이름</h2>
            <div id="player-names"></div>
        </div>
        <div class="results-input">
            <h2>결과</h2>
            <div id="game-results"></div>
        </div>
    </div>

    <button id="start-game">사다리 시작!</button>

    <div id="ladder-container"></div>

    <div id="game-output"></div>

    <script id="ladder-game-script">
    document.addEventListener('DOMContentLoaded', () => {
        const numPlayersInput = document.getElementById('num-players');
        const generateInputsBtn = document.getElementById('generate-inputs');
        const playerNamesDiv = document.getElementById('player-names');
        const gameResultsDiv = document.getElementById('game-results');
        const startGameBtn = document.getElementById('start-game');
        const ladderContainer = document.getElementById('ladder-container');
        const gameOutputDiv = document.getElementById('game-output'); // Keep for now, but its content will be empty

        let playerNames = [];
        let gameResults = [];
        let ladder = [];
        let pathMap = []; // Stores the final column index for each starting player

        const generatePlayerInputs = () => {
            const numPlayers = parseInt(numPlayersInput.value);
            playerNamesDiv.innerHTML = '';
            gameResultsDiv.innerHTML = '';
            playerNames = [];
            
            for (let i = 0; i < numPlayers; i++) {
                const nameGroup = document.createElement('div');
                nameGroup.className = 'player-input-group';
                nameGroup.innerHTML = `
                    <label for="player-name-${i}">${i + 1}.</label>
                    <input type="text" id="player-name-${i}" placeholder="이름 입력" value="">
                `;
                playerNamesDiv.appendChild(nameGroup);

                // For results input, we still generate, but the actual gameResults will be handled by the game logic
                const resultGroup = document.createElement('div');
                resultGroup.className = 'player-input-group';
                resultGroup.innerHTML = `
                    <label for="game-result-${i}">${i + 1}.</label>
                    <input type="text" id="game-result-${i}" placeholder="결과 입력" value="">
                `;
                gameResultsDiv.appendChild(resultGroup);
            }

            // Determine winner position right after generating inputs
            if (numPlayers > 0) {
                const 꽝Phrases = ['꽝', '다음 기회에', '아쉽게도..', '재도전!', '실패', '행운을 빌어요'];
                let finalOutcomesPool = Array(numPlayers).fill(null); // Use null initially
                const winnerIndex = Math.floor(Math.random() * numPlayers); // Randomly select ONE column to be '당첨'
                finalOutcomesPool[winnerIndex] = '당첨';

                // Fill non-winner spots with random '꽝' phrases
                for (let i = 0; i < numPlayers; i++) {
                    if (finalOutcomesPool[i] === null) {
                        const random꽝Index = Math.floor(Math.random() * 꽝Phrases.length);
                        finalOutcomesPool[i] = 꽝Phrases[random꽝Index];
                    }
                }
                gameResults = finalOutcomesPool; // The outcomes are now directly tied to column index. Randomness comes from path.


            } else {
                gameResults = [];
            }
        };

        const drawLadder = () => {
            const numPlayers = playerNames.length;
            const ladderHeight = 300; // px
            const rungCount = Math.floor(ladderHeight / 30) - 1; // Number of possible rungs, increased density

            ladderContainer.innerHTML = ''; // Clear previous ladder
            ladderContainer.style.width = `${numPlayers * 80 + (numPlayers - 1) * 0}px`; // Adjust width based on players
            ladderContainer.style.height = `${ladderHeight + 60}px`; // Add space for names and results
            ladderContainer.style.position = 'relative';

            ladder = Array.from({ length: numPlayers }, () => Array(rungCount).fill(0)); // 0: no rung, 1: rung to right, -1: rung to left

            // Draw vertical lines and generate rungs
            for (let i = 0; i < numPlayers; i++) {
                const column = document.createElement('div');
                column.className = 'ladder-column';
                column.style.left = `${i * 80}px`; // Spacing between columns
                column.style.height = `${ladderHeight}px`;
                column.style.position = 'absolute';
                column.style.top = '30px'; // Offset to make space for names

                // Add name at the top
                const nameDisplay = document.createElement('div');
                nameDisplay.className = 'ladder-top-name';
                nameDisplay.textContent = playerNames[i];
                nameDisplay.style.left = `${i * 80 + 40}px`; // Center name above column
                nameDisplay.style.top = `0px`;
                ladderContainer.appendChild(nameDisplay);


                const line = document.createElement('div');
                line.className = 'ladder-line';
                line.style.height = '100%';
                column.appendChild(line);

                // Add rungs randomly
                if (i < numPlayers - 1) { // Don't add rungs from the last column to the right
                    for (let j = 0; j < rungCount; j++) {
                        if (Math.random() < 0.6) { // 60% chance to add a rung (increased density)
                            // Check if a rung already exists to the left
                            if (ladder[i][j] === 0 && ladder[i + 1][j] === 0) { // Ensure no overlapping rungs
                                const rung = document.createElement('div');
                                rung.className = 'rung';
                                rung.style.top = `${(j + 1) * (ladderHeight / (rungCount + 1))}px`;
                                rung.style.left = `2px`; // Position relative to current column line
                                rung.style.width = `${80 - 4}px`; // Width between columns - padding
                                column.appendChild(rung);
                                ladder[i][j] = 1;
                                ladder[i + 1][j] = -1;
                            }
                        }
                    }
                }

                ladderContainer.appendChild(column);

                // Add placeholder for result at the bottom
                const resultDisplay = document.createElement('div');
                resultDisplay.className = 'ladder-bottom-result';
                resultDisplay.id = `result-col-${i}`; // Unique ID for later update
                resultDisplay.textContent = gameResults[i]; // Display pre-determined result
                if (gameResults[i] === '당첨') {
                    resultDisplay.classList.add('blink-winner'); // Add blinking effect
                }
                resultDisplay.style.left = `${i * 80 + 40}px`; // Center result below column
                resultDisplay.style.top = `${ladderHeight + 30}px`;
                ladderContainer.appendChild(resultDisplay);
            }
        };

        const runLadder = (startIndex) => {
            const numPlayers = playerNames.length;
            const ladderHeight = 300;
            const rungCount = ladder[0].length;
            const rungSpacing = ladderHeight / (rungCount + 1);

            let currentX = startIndex;
            // The path starts from the top of the ladder (y=0 relative to ladder_line start)
            // Need to adjust for the 30px offset of the ladder columns from the container top
            let currentYOffset = 30;

            const path = [];
            // Starting point, adjusted for column top offset
            path.push({ x: startIndex * 80 + 40, y: currentYOffset }); // Centered at the top of the column

            for (let j = 0; j < rungCount; j++) {
                // Move down to the next rung position, adjusted for column top offset
                path.push({ x: currentX * 80 + 40, y: currentYOffset + (j + 1) * rungSpacing });

                if (ladder[currentX][j] === 1) { // Rung to the right
                    currentX++;
                    path.push({ x: currentX * 80 + 40, y: currentYOffset + (j + 1) * rungSpacing });
                } else if (ladder[currentX][j] === -1) { // Rung to the left
                    currentX--;
                    path.push({ x: currentX * 80 + 40, y: currentYOffset + (j + 1) * rungSpacing });
                }
            }
            pathMap[startIndex] = currentX; // Map starting column to ending column
            return path;
        };

        const drawPath = (path, color, playerIndex) => {
            // This function now just prepares the path segments, animation handled by animatePath
            const segmentElements = [];
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];

                const segment = document.createElement('div');
                segment.className = 'ladder-path-segment';
                segment.style.position = 'absolute';
                segment.style.backgroundColor = color;
                segment.style.zIndex = '1';
                segment.style.opacity = '0'; // Start invisible

                if (p1.x === p2.x) { // Vertical segment
                    segment.style.left = `${p1.x - 1}px`;
                    segment.style.top = `${Math.min(p1.y, p2.y)}px`;
                    segment.style.width = `2px`;
                    segment.style.height = `${Math.abs(p2.y - p1.y)}px`;
                } else { // Horizontal segment
                    segment.style.left = `${Math.min(p1.x, p2.x)}px`;
                    segment.style.top = `${p1.y - 1}px`;
                    segment.style.width = `${Math.abs(p2.x - p1.x)}px`;
                    segment.style.height = `2px`;
                }
                ladderContainer.appendChild(segment);
                segmentElements.push(segment);
            }
            return segmentElements; // Return elements for animation
        };

        const animatePath = (segmentElements, resultDisplayElement, finalResult, color, delay = 150) => {
            let i = 0;
            const interval = setInterval(() => {
                if (i < segmentElements.length) {
                    segmentElements[i].style.opacity = '1'; // Make segment visible
                    i++;
                } else {
                    clearInterval(interval);
                    if (resultDisplayElement) {
                        resultDisplayElement.textContent = finalResult;
                        resultDisplayElement.style.color = color;
                    }
                }
            }, delay);
        };

        generateInputsBtn.addEventListener('click', generatePlayerInputs);
        startGameBtn.addEventListener('click', async () => { // Changed to async
            gameOutputDiv.innerHTML = ''; // Clear game output area

            playerNames = [];

            const numPlayers = parseInt(numPlayersInput.value);
            for (let i = 0; i < numPlayers; i++) {
                playerNames.push(document.getElementById(`player-name-${i}`).value.trim() || `참가자 ${i + 1}`);
            }

            // Validation (still need valid names)
            const validPlayerNames = playerNames.filter(name => name !== '');
            if (validPlayerNames.length < 2 || validPlayerNames.length > 10) {
                alert('참가자 수는 2명에서 10명 사이여야 하며, 유효한 이름이 입력되어야 합니다.');
                return;
            }

            drawLadder(); // This will also display the pre-determined results

            // Remove blinking class from all results initially
            document.querySelectorAll('.ladder-bottom-result').forEach(el => el.classList.remove('blink-winner'));


            pathMap = Array(numPlayers).fill(0); // Reset pathMap for new game

            const colors = ['red', 'blue', 'green', 'purple', 'orange', 'brown', 'pink', 'teal', 'navy', 'maroon'];

            // Clear previous paths
            document.querySelectorAll('.ladder-path-segment').forEach(el => el.remove());

            // Animate paths one by one
            const animationDelayPerSegment = 150; // Milliseconds per segment
            for (let i = 0; i < numPlayers; i++) {
                const path = runLadder(i);
                const segmentElements = drawPath(path, colors[i % colors.length], i); // Pass player index if needed
                const finalResultForPlayer = gameResults[pathMap[i]]; // Use pre-determined result
                const resultDisplayElement = document.getElementById(`result-col-${pathMap[i]}`);

                await new Promise(resolve => {
                    animatePath(segmentElements, resultDisplayElement, finalResultForPlayer, colors[i % colors.length], animationDelayPerSegment);
                    // A small delay between player animations to make it clear
                    setTimeout(resolve, segmentElements.length * animationDelayPerSegment + 500); // Use new delay
                });
            }

            // After all animations are complete, update the input result fields
            await new Promise(resolve => {
                setTimeout(() => { // Small delay to ensure all animations are visually complete
                    for (let i = 0; i < numPlayers; i++) {
                        const playerInputResultField = document.getElementById(`game-result-${i}`);
                        if (playerInputResultField) {
                            const finalLandingColumn = pathMap[i];
                            playerInputResultField.value = gameResults[finalLandingColumn];
                        }
                    }
                    resolve();
                }, 500); // Wait a bit after the last animation resolves
            });
        });

        // Initial generation of inputs
        generatePlayerInputs();
    });
</script>
</body>
</html>